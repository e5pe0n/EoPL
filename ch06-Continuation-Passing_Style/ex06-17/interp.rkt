#lang eopl

(require "utils.rkt")
(require "data-structures.rkt")
(require "lang.rkt")
(require "errors.rkt")

(provide (all-defined-out))

(define exp 'uninitialized)
(define simple 'uninitialized)
(define env 'uninitialized)
(define val1 'uninitialized)
(define val2 'uninitialized)
(define proc1 'uninitialized)

; FinalAnswer = ExpVal
; Program -> FinalAnswer
(define value-of-program
  (lambda (pgm)
    (cases program pgm
      (a-program (exp1)
        (set! exp exp1)
        (set! env (init-env))
        (value-of/k)
        (trampoline)
        val1
      )
    )
  )
)

(define trampoline
  (lambda ()
    (if (expval? val1)
      val1
      (begin
        (val1)
        (trampoline)
      )
    )
  )
)

; TfExp * Env -> FinalAnswer
(define value-of/k
  (lambda ()
    (cases tf-expression exp
      (simple-exp->exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
      )
      (cps-let-exp (vars rhss body)
        (begin
          (set! exp body)
          (let f ([ss rhss] [vals '()])
            (if (null? ss)
              (set! val1 vals)
              (begin
                (set! simple (car ss))
                (value-of-simple-exp)
                (f (cdr ss) (append vals (list val1)))
              )
            )
          )
          (set! env (extend-env* vars val1 env))
          (value-of/k)
        )
      )
      (cps-letrec-exp (p-names b-varss p-bodies letrec-body)
        (set! exp letrec-body)
        (set! env (extend-env-rec* p-names b-varss p-bodies env))
        (value-of/k)
      )
      (cps-if-exp (simple1 body1 body2)
        (set! simple simple1)
        (value-of-simple-exp)
        (if (cases expval val1
              (num-val (num) (not (= num 0)))
              (bool-val (bool) bool)
              (proc-val (proc1) #t)
              (list-val (list1) (not (null? list1)))
            )
          (begin
            (set! exp body1)
            (value-of/k)
          )
          (begin
            (set! exp body2)
            (value-of/k)
          )
        )
      )
      (cps-call-exp (rator rands)
        (begin
          (set! simple rator)
          (value-of-simple-exp)
          (set! proc1 (expval->proc val1))
          (let f ([ss rands] [vals '()])
            (if (null? ss)
              (set! val1 vals)
              (begin
                (set! simple (car ss))
                (value-of-simple-exp)
                (f (cdr ss) (append vals (list val1)))
              )
            )
          )
          (apply-procedure/k)
        )
      )
    )
  )
)

; SimpleExp * Env -> FinalAnswer
(define value-of-simple-exp
  (lambda ()
    (cases simple-expression simple
      (const-exp (num) (set! val1 (num-val num)))
      (var-exp (var) (set! val1 (apply-env env var)))
      (cps-diff-exp (simple1 simple2)
        (begin
          (set! simple simple1)
          (value-of-simple-exp)
          (set! val2 val1)
          (set! simple simple2)
          (value-of-simple-exp)
          (set! val1 (num-val (- (expval->num val2) (expval->num val1))))
        )
      )
      (cps-mul-exp (simple1 simple2)
        (begin
          (set! simple simple1)
          (value-of-simple-exp)
          (set! val2 val1)
          (set! simple simple2)
          (value-of-simple-exp)
          (set! val1 (num-val (* (expval->num val2) (expval->num val1))))
        )
      )
      (cps-add1-exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val1 (num-val (+ (expval->num val1) 1)))
      )
      (cps-zero?-exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val1 (bool-val (zero? (expval->num val1))))
      )
      (cps-number?-exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val1
          (bool-val
            (cases expval val1
              (num-val (num) #t)
              (else #f)
            )
          )
        )
      )
      (cps-equal?-exp (simple1 simple2)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! simple simple2)
        (set! val2 val1)
        (value-of-simple-exp)
        (set! val1 (bool-val (= (expval->num val2) (expval->num val1))))
      )
      (cps-less?-exp (simple1 simple2)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! simple simple2)
        (set! val2 val1)
        (value-of-simple-exp)
        (set! val1 (bool-val (< (expval->num val2) (expval->num val1))))
      )
      (cps-greater?-exp (simple1 simple2)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! simple simple2)
        (set! val2 val1)
        (value-of-simple-exp)
        (set! val1 (bool-val (> (expval->num val2) (expval->num val1))))
      )
      (cps-null?-exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val1 (bool-val (null? (expval->list val1))))
      )
      (cps-proc-exp (vars tf-exp)
        (set! val1 (proc-val (procedure vars tf-exp env)))
      )
      (cps-emptylist-exp () (set! val1 (list-val '())))
      (cps-list-exp (simples)
        (begin
          (let f ([ss simples] [vals '()])
            (if (null? ss)
              (set! val1 (list-val vals))
              (begin
                (set! simple (car ss))
                (value-of-simple-exp)
                (f (cdr ss) (append vals (list (expval->any val1))))
              )
            )
          )
        )
      )
      (cps-car-exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val1 (any->expval (car (expval->list val1))))
      )
      (cps-cdr-exp (simple1)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val1 (list-val (cdr (expval->list val1))))
      )
      (cps-cons-exp (simple1 simple2)
        (set! simple simple1)
        (value-of-simple-exp)
        (set! val2 val1)
        (set! simple simple2)
        (value-of-simple-exp)
        (set! val1 (list-val (cons (expval->any val2) (expval->list val1))))
      )
    )
  )
)

; Proc * ExpVal -> FinalAnswer
(define apply-procedure/k
  (lambda ()
    (let ([val val1])
      (set! val1
        (lambda ()
          (cases proc proc1
            (procedure (vars body saved-env)
              (begin
                (set! exp body)
                (set! env (extend-env* vars val saved-env))
                (value-of/k)
              )
            )
          )
        )
      )
    )
  )
)
